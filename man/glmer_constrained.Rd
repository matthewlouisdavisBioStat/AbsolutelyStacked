% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmer_constrained.R
\name{glmer_constrained}
\alias{glmer_constrained}
\title{Fit generalized linear models and conditional mixed-effects models using constrained maximum likelihood estimation.}
\usage{
glmer_constrained(
  link_function,
  X,
  Y,
  Z,
  tau,
  est_tau = F,
  sigmas = 1,
  beta_update,
  u_update,
  lambda = 0,
  sigma_list,
  use_quadprog = F,
  sum_constraint = 1,
  lower_bound_constraint = 0
)
}
\arguments{
\item{link_function}{character, what link function is being used to model the GLM. Options include: linear, logit, log, probit, weibull, softmax, or inverse}

\item{X}{a list of matrices for softmax regression, a matrix for all other link functions, corresponding to fixed effects (the effect subject to constraint)}

\item{Y}{a matrix for softmax regression, a vector for all other link functions, corresponding to the outcome of interest}

\item{Z}{a list of matrices for softmax regression, a matrix for all other link functions, corresponding to random effects to be estimated}

\item{tau}{exponential dispersion parameter, fixed if est_tau == F}

\item{est_tau}{T or F, should the exponential dispersion parameter be estimated?}

\item{sigmas}{vector of numeric elements corresponding to intial values for the variance components associated with random effects.}

\item{beta_update}{a vector corresponding to the initial values of the fixed effects of interest.}

\item{u_update}{a vector corresponding to the intial values of the random effects of interest}

\item{lambda}{manually-specified l2-norm penalty: this appears in the score and information, but is excluded when computing the log-likelihood. Defaults to 0, but set to 0.000001 for make_glmerStackedModel().}

\item{sigma_list}{a list named by each random-effect variance parameter, each element of which is a vector containing the column indices of the Z matrix that correspond to each random-effect variance component.}

\item{use_quadprog}{T or F, should sequential quadratic programming using the quadprog package (T) or a general non-linear programmming algorithm using the Rsolnp package (F) be used to find MLEs under constraint. Defaults to F.}

\item{sum_constraint}{real number referring to the sum-constraint on fixed effect coefficients.}

\item{lower_bound_constraint}{real number (or vector with length equal to the length beta_update AND the number of columns of X) defining the lower bound constraint on fixed effect coefficients.}
}
\value{
A list of elements including constrained and unconstrained estimates of MLE weights.
}
\description{
Fit generalized linear models and conditional mixed-effects models using constrained maximum likelihood estimation.
}
\details{
First, generalized linear mixed effects models are fit using unconstrained maximum likelihood estimation via a damped Newton-Raphson algorithm. Coefficients are then updated to reflect the desired constraints, with initial values supplied to the functions based off of the unconstrained MLEs.
}
\examples{
\donttest{

## Simulate Data
library(magrittr)
N <- 1000
Xt <- cbind((runif(N)),(runif(N)),(runif(N)),(runif(N)))
Bt <- 2*c(-.25,0,0.25,0.75)
Zt <- kronk(lapply(1:10,function(i){
  cbind(rep(1,N/10))
}))
Ut <- rnorm(10,0,2)
## sse estimate of sigma^2 for observed error term for intializing (N-qr(Xt)$rank))
Mut <- Xt \%*\% Bt + Zt \%*\% Ut
Yt <- sapply(Mut,function(mu)rnorm(1,mu))
tau <- sd(Yt) ## for intializing only.....


## setup for random efx
Z <- Zt
sigma_list <- list("sigma_1" = 1:(ncol(Z)))
names(sigma_list) <- paste0("sigma_",1:length(sigma_list))
for(i in 1:length(sigma_list)){
  names(sigma_list[[i]]) <- rep(names(sigma_list)[i],
                                length(sigma_list[[i]]))
}
sigmas <- 1 ## for initializing only
names(sigmas) <- names(sigma_list)

## Constrained Maximum Likelihood-Based stacking
stacked_output_solnp <- glmer_constrained(
  link_function = 'linear',
  X = Xt,
  Y = Yt,
  Z = Z,
  tau = 1,
  est_tau = T,
  sigmas = sigmas,
  beta_update = rep(1/ncol(Xt),ncol(Xt)),
  u_update = rep(0,ncol(Z)),
  lambda = 0,
  sigma_list = sigma_list,
  use_quadprog = F,
  sum_constraint = sum(Bt),
  lower_bound_constraint = c(-.5,0,0,0)
)
stacked_output_qp <- glmer_constrained(
  link_function = 'linear',
  X = Xt,
  Y = Yt,
  Z = Z,
  tau = 1,
  est_tau = T,
  sigmas = sigmas,
  beta_update = rep(1/ncol(Xt),ncol(Xt)),
  u_update = rep(0,ncol(Z)),
  lambda = 0,
  sigma_list = sigma_list,
  use_quadprog = T,
  sum_constraint = sum(Bt),
  lower_bound_constraint = c(-.5,0,0,0)
)

## GLM (requires installation of lme4 for testing purposes)
Z2 <- apply(Z,1,function(z){
  sum(sapply(1:10,function(i){
    i*(z[i]==1)
  }))
})
temp_data <- as.data.frame(cbind(Yt,Xt,Z2))
colnames(temp_data) <- c(
  "Y",
  paste0("X",1:ncol(Xt)),
  "Z"
)
fitLMERraw <- lme4::lmer(as.formula(
  "Y ~ 0 + X1 + X2 + X3 + X4 + (1|Z)"
),data = temp_data)
fitLMER <- fitLMERraw \%>\%
  summary
u_hat <- (fitLMERraw \%>\% coef)[[1]][,1]
mle <- c(fitLMER$coefficients[,1])


res <- data.frame(c(Bt,Ut),
                  round(c(stacked_output_solnp$beta_update,stacked_output_solnp$u_update),4),
                  round(c(stacked_output_qp$beta_update,stacked_output_qp$u_update),4),
                  round(c(stacked_output_solnp$beta_mle,stacked_output_solnp$u_update),4),
                  round(c(mle,u_hat),4))
colnames(res) <- c("True Betas",
                   "Constrained MLE Rsolnp",
                   "Constrained MLE quadprog",
                   "Unconstrained MLE glmer_constrained",
                   "Unconstrained MLE lmer")
rownames(res) <- c("Beta1", "Beta2" ,"Beta3","Beta4",paste0("RandInt",1:10))
print(res)
}
}
\seealso{
\code{\link[quadprog]{solve.QP}}, \code{\link[Rsolnpl]{solnp}}
}
